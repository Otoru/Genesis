---
title: Observability
weight: 60
---

# Observability

Genesis comes with built-in instrumentation for **OpenTelemetry**, allowing you to trace connections, commands, and events in your application.

## OpenTelemetry Instrumentation

The library uses the `opentelemetry-api` to emit traces. To collect these traces, you must configure the OpenTelemetry SDK in your application.

### Automatic Spans

Genesis generates the following spans automatically:

| Span Name | Module | Description | Attributes |
|-----------|--------|-------------|------------|
| `inbound_connect` | `Inbound` | Connection to FreeSWITCH | `net.peer.name`, `net.peer.port` |
| `send_command` | `Protocol` | Sending ESL commands | `command.name`, `command.reply` |
| `process_event` | `Protocol` | Processing received events | `event.name`, `event.uuid` |
| `outbound_handle_connection` | `Outbound` | Handling incoming calls | `net.peer.name`, `net.peer.port` |

### Configuration Example

To see traces, you need to install the OpenTelemetry SDK and an exporter (e.g., to console or Jaeger/OTLP).

```bash
pip install opentelemetry-sdk
```

Here is an example of how to configure a simple Console Exporter to print traces to stdout:

```python
import asyncio
from genesis import Inbound
# OpenTelemetry imports
from opentelemetry import trace
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import ConsoleSpanExporter, SimpleSpanProcessor

# 1. Configure OpenTelemetry SDK
provider = TracerProvider()
processor = SimpleSpanProcessor(ConsoleSpanExporter())
provider.add_span_processor(processor)
trace.set_tracer_provider(provider)

async def main():
    # 2. Use Genesis as usual
    async with Inbound("127.0.0.1", 8021, "ClueCon") as client:
        # This action will generate 'inbound_connect' and 'send_command' spans
        await client.send("uptime")

if __name__ == "__main__":
    asyncio.run(main())
```

If you are using **FastAPI** or other frameworks that already configure OpenTelemetry, Genesis will automatically attach its spans to the active trace.

## Example Output

Here are examples of the spans generated by Genesis (JSON formatted for readability):

### Connection Span
```json
{
    "name": "inbound_connect",
    "context": {
        "trace_id": "0x75ebc8f0bdec863810c0ed3d0ae80a60",
        "span_id": "0x97b9f897c3d67569",
        "trace_state": "[]"
    },
    "kind": "SpanKind.INTERNAL",
    "status": { "status_code": "UNSET" },
    "attributes": {
        "net.peer.name": "127.0.0.1",
        "net.peer.port": 50485
    }
}
```

### Command Span
```json
{
    "name": "send_command",
    "context": {
        "trace_id": "0x37415043ec8874f9b0b4d2addb596c37",
        "span_id": "0x665d31cc8917d78b",
        "trace_state": "[]"
    },
    "kind": "SpanKind.INTERNAL",
    "attributes": {
        "command.name": "uptime",
        "command.reply": "6943047"
    }
}
```

### Event Processing Span
```json
{
    "name": "process_event",
    "context": {
        "trace_id": "0x37f183900d199ebdf9de86d91a4c2899",
        "span_id": "0xa0ec0ba49e0d30c2",
        "trace_state": "[]"
    },
    "kind": "SpanKind.INTERNAL",
    "attributes": {
        "event.name": "CUSTOM",
        "event.uuid": "1234",
        "event.content_type": "text/event-plain",
        "event.header.event_subclass": "my::subclass",
        "event.header.event_sequence": "50",
        "event.header.channel_state": "CS_EXECUTE"
    }
}
```
*Note: All event headers are flattened into `event.header.{snake_case_name}` attributes, allowing for easy filtering of specific event properties.*


### Outbound Connection Span
When using Genesis in **Outbound** mode (receiving connections from FreeSWITCH), a span wraps the entire session handling:

```json
{
    "name": "outbound_handle_connection",
    "context": {
        "trace_id": "0x820fb5fb3de978ac94aff44a31a7dafe",
        "span_id": "0x1a059c1cee5377bf",
        "trace_state": "[]"
    },
    "kind": "SpanKind.INTERNAL",
    "attributes": {
        "net.peer.name": "127.0.0.1",
        "net.peer.port": 50692
    }
}
```


## Logging

Genesis integrates structured logging with OpenTelemetry.

### Log Correlation

When logs are generated within an active trace span, Genesis automatically injects the `trace_id` and `span_id` into the log record.

**Default Output (Rich):**
```text
[10:34:43] INFO     This is a log message (trace_id=... span_id=...)
```

### JSON Logging

For production environments, you can enable JSON logging to output structured logs ideal for ingestion by tools like ELK, Grafana Loki, or Splunk.

Use the `--json` flag when running the CLI:

```bash
genesis --json outbound ...
```

**JSON Output:**
```json
{
  "timestamp": "2026-01-16T13:35:11.813625+00:00",
  "level": "INFO",
  "message": "This is a log message",
  "logger": "genesis.logger",
  "trace_id": "eee4dfc73530a13a846ec8f1e61561f4",
  "span_id": "639ec6ffc3f956f2"
}
```

## Metrics

Genesis exposes metrics via OpenTelemetry, which can be scraped by **Prometheus**.

### CLI Automatic Exposure

When running Genesis via the CLI (`genesis ...`), a Prometheus metrics server is automatically started.

- **Default Port**: `8000`
- **Configuration**: Set the `GENESIS_METRICS_PORT` environment variable to change the port.

```bash
export GENESIS_METRICS_PORT=9090
genesis consumer ...
```

### Available Metrics

| OpenTelemetry Name | Prometheus Name | Type | Description | Attributes |
|--------------------|-----------------|------|-------------|------------|
| `genesis.commands.sent` | `genesis_commands_sent_total` | Counter | Number of ESL commands sent | `command` |
| `genesis.events.received` | `genesis_events_received_total` | Counter | Number of ESL events received | `event_name`, `event_subclass`, `direction`, `channel_state`, `answer_state`, `hangup_cause` |
| `genesis.commands.duration` | `genesis_commands_duration_seconds` | Histogram | Duration of command execution (RTT) | `command` |
| `genesis.connections.active` | `genesis_connections_active` | Gauge | Number of active connections | `type` (inbound/outbound) |
| `genesis.connections.errors` | `genesis_connections_errors_total` | Counter | Number of connection errors | `type`, `error` (timeout/auth_failed) |
| `genesis.commands.errors` | `genesis_commands_errors_total` | Counter | Number of failed ESL commands | `command`, `error` |

> **Note:** OpenTelemetry uses dot notation (`.`) by convention, but the Prometheus exporter automatically converts dots to underscores (`_`) and appends `_total` to counters.

### Manual Configuration (Library Usage)

If you use Genesis as a library (without the CLI), you must configure the exporter manually:

```python
import asyncio
from opentelemetry import metrics
from opentelemetry.sdk.metrics import MeterProvider
from opentelemetry.sdk.resources import Resource
from opentelemetry.exporter.prometheus import PrometheusMetricReader
from prometheus_client import start_http_server
from genesis import Inbound

# 1. Start Prometheus HTTP Server
start_http_server(8000)

# 2. Configure OpenTelemetry
metric_reader = PrometheusMetricReader()
provider = MeterProvider(
    resource=Resource.create({"service.name": "genesis-app"}),
    metric_readers=[metric_reader],
)
metrics.set_meter_provider(provider)

async def main():
    print("Metrics at http://localhost:8000/metrics")
    async with Inbound("127.0.0.1", 8021, "ClueCon") as client:
        await client.send("uptime")
        await asyncio.sleep(60) # Keep running

if __name__ == "__main__":
    asyncio.run(main())
```
